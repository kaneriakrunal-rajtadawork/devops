import User from "@/models/User.model";
import { BaseService } from "./base.service";
import { NotFoundError, ValidationError, DatabaseError, UnauthorizedError } from "@/lib/errors";
import { validateData } from "@/lib/validation";
import { userSchema, createUserSchema, updateUserSchema, loginSchema, changePasswordSchema, emsUserSchema, githubUserSchema } from "@/lib/validations";
import { generateStrongPassword } from "@/utils/functions";
import connectDB from "@/lib/mongodb";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import GLOBALS from "@/constants/globals.constants";

/**
 * User service extending BaseService with user-specific functionality
 */
class UserService extends BaseService {
  constructor() {
    super(User);
  }

  /**
   * Create user from EMS system
   */
  async createFromEMS(userData) {
    try {
      await connectDB();
      const validatedData = validateData(emsUserSchema, userData);
      
      // Check if user exists
      const existingUser = await User.findByEmail(validatedData.email);
      if (existingUser) {
        throw new ValidationError("User with this email already exists");
      }

      // Generate password
      const password = generateStrongPassword(12);
      
      // Prepare user object
      const userToCreate = {
        ...validatedData,
        password,
        autoGeneratedPassword: true,
        isFromEMS: true
      };

      const newUser = await this.create(userToCreate);
      
      // Return safe response with generated password
      return { 
        ...newUser.toSafeObject(), 
        password // Only return password for EMS creation
      };
    } catch (error) {
      if (error instanceof ValidationError) throw error;
      throw new DatabaseError(`Failed to create user from EMS: ${error.message}`);
    }
  }

  /**
   * Register a new user
   */
  async register(userData) {
    try {
      await connectDB();
      const validatedData = validateData(createUserSchema, userData);
      
      // Check if user exists
      const existingUser = await User.findByEmail(validatedData.email);
      if (existingUser) {
        throw new ValidationError("User with this email already exists");
      }

      const newUser = await this.create(validatedData);
      return newUser.toSafeObject();
    } catch (error) {
      if (error instanceof ValidationError) throw error;
      throw new DatabaseError(`Failed to register user: ${error.message}`);
    }
  }

  /**
   * Authenticate user login
   */
  async login(credentials) {
    try {
      await connectDB();
      const validatedData = validateData(loginSchema, credentials);
      
      // Find user and include password and githubAccessToken for comparison
      const user = await User.findByEmail(validatedData.email).select('+password +githubAccessToken +userId +githubUsername +name');
      if (!user) {
        throw new UnauthorizedError("Invalid credentials");
      }

      if (!user.isActive) {
        throw new UnauthorizedError("Account is deactivated");
      }

      // Compare password
      const isPasswordValid = await user.comparePassword(validatedData.password);
      if (!isPasswordValid) {
        throw new UnauthorizedError("Invalid credentials");
      }

      // Update last login
      await user.updateLastLogin();

      // Generate JWT token
      const token = this.generateToken(user);

      // Create safe user object but include GitHub integration status
      const safeUser = user.toSafeObject();
      safeUser.hasGitHubIntegration = !!(user.githubAccessToken && user.githubUsername);
      
      // Only include githubAccessToken if it exists (for API calls)
      if (user.githubAccessToken) {
        safeUser.githubAccessToken = user.githubAccessToken;
      }

      return {
        token,
        user: safeUser
      };
    } catch (error) {
      if (error instanceof ValidationError || error instanceof UnauthorizedError) throw error;
      throw new DatabaseError(`Login failed: ${error.message}`);
    }
  }

  /**
   * Get user profile by ID
   */
  async getProfile(userId) {
    try {
      const user = await this.findById(userId);
      if (!user) {
        throw new NotFoundError("User not found");
      }
      return user.toSafeObject();
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to get user profile: ${error.message}`);
    }
  }

  /**
   * Get user profile with GitHub access token (for API calls)
   */
  async getProfileWithGithubToken(userId) {
    try {
      await connectDB();
      const user = await User.findById(userId).select('+githubAccessToken');
      if (!user) {
        throw new NotFoundError("User not found");
      }
      
      const safeUser = user.toSafeObject();
      safeUser.hasGitHubIntegration = !!(user.githubAccessToken && user.githubUsername);
      
      // Include GitHub access token if it exists
      if (user.githubAccessToken) {
        safeUser.githubAccessToken = user.githubAccessToken;
      }
      
      return safeUser;
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to get user profile: ${error.message}`);
    }
  }

  /**
   * Update user profile
   */
  async updateProfile(userId, updateData) {
    try {
      const validatedData = validateData(updateUserSchema, updateData);
      
      const updatedUser = await this.update(userId, validatedData);
      if (!updatedUser) {
        throw new NotFoundError("User not found");
      }
      
      return updatedUser.toSafeObject();
    } catch (error) {
      if (error instanceof ValidationError || error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to update user profile: ${error.message}`);
    }
  }

  /**
   * Change user password
   */
  async changePassword(userId, passwordData) {
    try {
      await connectDB();
      const validatedData = validateData(changePasswordSchema, passwordData);
      
      // Find user with password
      const user = await User.findById(userId).select('+password');
      if (!user) {
        throw new NotFoundError("User not found");
      }

      // Verify current password
      const isCurrentPasswordValid = await user.comparePassword(validatedData.currentPassword);
      if (!isCurrentPasswordValid) {
        throw new UnauthorizedError("Current password is incorrect");
      }

      // Update password (pre-save hook will hash it)
      user.password = validatedData.newPassword;
      user.autoGeneratedPassword = false;
      await user.save();

      return { message: "Password changed successfully" };
    } catch (error) {
      if (error instanceof ValidationError || error instanceof NotFoundError || error instanceof UnauthorizedError) throw error;
      throw new DatabaseError(`Failed to change password: ${error.message}`);
    }
  }

  /**
   * Connect GitHub account
   */
  async connectGitHub(userId, githubData) {
    try {
      await connectDB();
      const validatedData = validateData(githubUserSchema, githubData);
      
      const user = await User.findById(userId);
      if (!user) {
        throw new NotFoundError("User not found");
      }

      // Check if GitHub account is already connected to another user
      const existingGitHubUser = await User.findByGithubId(validatedData.githubId);
      if (existingGitHubUser && existingGitHubUser._id.toString() !== userId) {
        throw new ValidationError("GitHub account is already connected to another user");
      }

      await user.connectGitHub(validatedData);
      return user.toSafeObject();
    } catch (error) {
      if (error instanceof ValidationError || error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to connect GitHub: ${error.message}`);
    }
  }

  /**
   * Disconnect GitHub account
   */
  async disconnectGitHub(userId) {
    try {
      await connectDB();
      const user = await User.findById(userId);
      if (!user) {
        throw new NotFoundError("User not found");
      }

      await user.disconnectGitHub();
      return user.toSafeObject();
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to disconnect GitHub: ${error.message}`);
    }
  }

  /**
   * Get all users (admin function)
   */
  async getAllUsers(filters = {}) {
    try {
      await connectDB();
      const query = {};
      
      if (filters.role) query.role = filters.role;
      if (filters.isFromEMS !== undefined) query.isFromEMS = filters.isFromEMS;
      if (filters.isActive !== undefined) query.isActive = filters.isActive;
      
      const users = await User.find(query)
        .select('name email role githubUsername isFromEMS isActive createdAt')
        .sort({ createdAt: -1 });
      
      return users.map(user => user.toSafeObject());
    } catch (error) {
      throw new DatabaseError(`Failed to get users: ${error.message}`);
    }
  }

  /**
   * Search users by name, email, or GitHub username
   */
  async searchUsers(searchTerm, limit = 10) {
    try {
      await connectDB();
      const users = await User.searchUsers(searchTerm, limit);
      return users.map(user => user.toSafeObject());
    } catch (error) {
      throw new DatabaseError(`Failed to search users: ${error.message}`);
    }
  }

  /**
   * Get users created from EMS
   */
  async getEMSUsers() {
    try {
      await connectDB();
      const users = await User.findEMSUsers();
      return users.map(user => user.toSafeObject());
    } catch (error) {
      throw new DatabaseError(`Failed to get EMS users: ${error.message}`);
    }
  }

  /**
   * Get user created from EMS
   */
  async getEMSUser(userId) {
    try {
      await connectDB();
      const user = await User.findOne({userId: userId});
      return user.toSafeObject();
    } catch (error) {
      throw new DatabaseError(`Failed to get EMS user: ${error.message}`);
    }
  }

  /**
   * Get global user ID for EMS integration
   */
  async getGlobalUserId(mongoDbUserId) {
    try {
      await connectDB();
      const user = await User.findById(mongoDbUserId, { userId: 1, _id: 0 });
      if (!user) {
        throw new NotFoundError("User not found");
      }
      return user.userId;
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to get global user ID: ${error.message}`);
    }
  }

  /**
   * Deactivate user account
   */
  async deactivateUser(userId) {
    try {
      const user = await this.update(userId, { isActive: false });
      if (!user) {
        throw new NotFoundError("User not found");
      }
      return user.toSafeObject();
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to deactivate user: ${error.message}`);
    }
  }

  /**
   * Activate user account
   */
  async activateUser(userId) {
    try {
      const user = await this.update(userId, { isActive: true });
      if (!user) {
        throw new NotFoundError("User not found");
      }
      return user.toSafeObject();
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      throw new DatabaseError(`Failed to activate user: ${error.message}`);
    }
  }

  /**
   * Generate JWT token
   */
  generateToken(user) {
    return jwt.sign(
      { 
        id: user._id, 
        email: user.email, 
        role: user.role,
        name: user.name,
        userId: user.userId || null,
        githubUsername: user?.githubUsername || "",
        githubAccessToken: user?.githubAccessToken || null
      },
      GLOBALS.JWT_SECRET || 'your_default_secret',
      { expiresIn: '24h' }
    );
  }

  /**
   * Verify JWT token
   */
  verifyToken(token) {
    try {
      return jwt.verify(token, GLOBALS.JWT_SECRET || 'your_default_secret');
    } catch (error) {
      throw new UnauthorizedError("Invalid or expired token");
    }
  }
}

// Create singleton instance
const userService = new UserService();

// Export methods for backward compatibility
export const createUser = (data) => userService.createFromEMS(data);
export const getGlobalUserId = (mongoDbUserId) => userService.getGlobalUserId(mongoDbUserId);
export const registerUser = (data) => userService.register(data);
export const loginUser = (credentials) => userService.login(credentials);
export const getUserProfile = (userId) => userService.getProfile(userId);
export const getUserProfileWithGithubToken = (userId) => userService.getProfileWithGithubToken(userId);
export const updateUserProfile = (userId, data) => userService.updateProfile(userId, data);
export const changeUserPassword = (userId, data) => userService.changePassword(userId, data);
export const connectUserGitHub = (userId, data) => userService.connectGitHub(userId, data);
export const disconnectUserGitHub = (userId) => userService.disconnectGitHub(userId);
export const getAllUsers = (filters) => userService.getAllUsers(filters);
export const searchUsers = (searchTerm, limit) => userService.searchUsers(searchTerm, limit);
export const getEMSUsers = () => userService.getEMSUsers();
export const getEMSUser = (id) => userService.getEMSUser(id);
export const deactivateUser = (userId) => userService.deactivateUser(userId);
export const activateUser = (userId) => userService.activateUser(userId);
export const generateUserToken = (user) => userService.generateToken(user);
export const verifyUserToken = (token) => userService.verifyToken(token);

export default userService;